<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: SymetrieCom::Acts::NestedSet::ClassMethods::SingletonMethods</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">SymetrieCom::Acts::NestedSet::ClassMethods::SingletonMethods</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../../../files/lib/better_nested_set_rb.html">
                lib/better_nested_set.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000012">check_all</a>&nbsp;&nbsp;
      <a href="#M000005">count_in_nested_set</a>&nbsp;&nbsp;
      <a href="#M000004">find_in_nested_set</a>&nbsp;&nbsp;
      <a href="#M000006">recurse_result_set</a>&nbsp;&nbsp;
      <a href="#M000013">renumber_all</a>&nbsp;&nbsp;
      <a href="#M000007">result_to_array</a>&nbsp;&nbsp;
      <a href="#M000009">result_to_attributes_xml</a>&nbsp;&nbsp;
      <a href="#M000008">result_to_xml</a>&nbsp;&nbsp;
      <a href="#M000010">root</a>&nbsp;&nbsp;
      <a href="#M000011">roots</a>&nbsp;&nbsp;
      <a href="#M000014">sql_for</a>&nbsp;&nbsp;
      <a href="#M000015">without_scope_condition</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000012" class="method-detail">
        <a name="M000012"></a>

        <div class="method-heading">
          <a href="#M000012" class="method-signature">
          <span class="method-name">check_all</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Checks the left/right indexes of all records, returning the number of
records checked. Throws ActiveRecord::ActiveRecordError if it finds a
problem.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000012-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000012-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 307</span>
307:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">check_all</span>
308:             <span class="ruby-identifier">total</span> = <span class="ruby-value">0</span>
309:             <span class="ruby-identifier">transaction</span> <span class="ruby-keyword kw">do</span>
310:               <span class="ruby-comment cmt"># if there are virtual roots, only call check_full_tree on the first, because it will check other virtual roots in that tree.</span>
311:               <span class="ruby-identifier">total</span> = <span class="ruby-identifier">roots</span>.<span class="ruby-identifier">inject</span>(<span class="ruby-value">0</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">r</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">r</span>[<span class="ruby-identifier">r</span>.<span class="ruby-identifier">left_col_name</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">check_full_tree</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span> )}
312:               <span class="ruby-identifier">raise</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">ActiveRecordError</span>, <span class="ruby-value str">&quot;Scope problems or nodes without a valid root&quot;</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">count</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">total</span>
313:             <span class="ruby-keyword kw">end</span>
314:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">total</span>
315:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000005" class="method-detail">
        <a name="M000005"></a>

        <div class="method-heading">
          <a href="#M000005" class="method-signature">
          <span class="method-name">count_in_nested_set</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Count wrapped in with_scope
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000005-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000005-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 109</span>
109:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">count_in_nested_set</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
110:             <span class="ruby-identifier">outer_scope</span>, <span class="ruby-identifier">inner_scope</span> = <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span>
111:               <span class="ruby-keyword kw">when</span> <span class="ruby-value">2</span> <span class="ruby-keyword kw">then</span> [<span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">args</span>[<span class="ruby-value">1</span>]]
112:               <span class="ruby-keyword kw">when</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">then</span> [<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>]]
113:               <span class="ruby-keyword kw">else</span> [<span class="ruby-keyword kw">nil</span>, <span class="ruby-keyword kw">nil</span>]
114:             <span class="ruby-keyword kw">end</span>
115:             <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">with_scope</span>(<span class="ruby-identifier">:find</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">outer_scope</span> <span class="ruby-operator">||</span> {})) <span class="ruby-keyword kw">do</span>
116:               <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">count</span>(<span class="ruby-identifier">inner_scope</span> <span class="ruby-operator">||</span> {})
117:             <span class="ruby-keyword kw">end</span>
118:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000004" class="method-detail">
        <a name="M000004"></a>

        <div class="method-heading">
          <a href="#M000004" class="method-signature">
          <span class="method-name">find_in_nested_set</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Most query methods are wrapped in with_scope to provide further filtering
<a href="SingletonMethods.html#M000004">find_in_nested_set</a>(what,
outer_scope, inner_scope) inner scope is user supplied, while outer_scope
is the normal query this way the user can override most scope attributes,
except :conditions which is merged; use :reverse =&gt; true to sort result
in reverse direction
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000004-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000004-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 93</span>
 93:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">find_in_nested_set</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
 94:             <span class="ruby-identifier">what</span>, <span class="ruby-identifier">outer_scope</span>, <span class="ruby-identifier">inner_scope</span> = <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span>
 95:               <span class="ruby-keyword kw">when</span> <span class="ruby-value">3</span> <span class="ruby-keyword kw">then</span> [<span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">args</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">args</span>[<span class="ruby-value">2</span>]]
 96:               <span class="ruby-keyword kw">when</span> <span class="ruby-value">2</span> <span class="ruby-keyword kw">then</span> [<span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">args</span>[<span class="ruby-value">1</span>]]
 97:               <span class="ruby-keyword kw">when</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">then</span> [<span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword kw">nil</span>, <span class="ruby-keyword kw">nil</span>]
 98:               <span class="ruby-keyword kw">else</span> [<span class="ruby-identifier">:all</span>, <span class="ruby-keyword kw">nil</span>, <span class="ruby-keyword kw">nil</span>]
 99:             <span class="ruby-keyword kw">end</span>
100:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">inner_scope</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">outer_scope</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">inner_scope</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:reverse</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">outer_scope</span>[<span class="ruby-identifier">:order</span>] <span class="ruby-operator">==</span> <span class="ruby-node">&quot;#{prefixed_left_col_name}&quot;</span>
101:               <span class="ruby-identifier">outer_scope</span>[<span class="ruby-identifier">:order</span>] = <span class="ruby-node">&quot;#{prefixed_right_col_name} DESC&quot;</span>
102:             <span class="ruby-keyword kw">end</span>
103:             <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">with_scope</span>(<span class="ruby-identifier">:find</span> =<span class="ruby-operator">&gt;</span> (<span class="ruby-identifier">outer_scope</span> <span class="ruby-operator">||</span> {})) <span class="ruby-keyword kw">do</span>
104:               <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">find</span>(<span class="ruby-identifier">what</span>, <span class="ruby-identifier">inner_scope</span> <span class="ruby-operator">||</span> {})
105:             <span class="ruby-keyword kw">end</span>
106:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000006" class="method-detail">
        <a name="M000006"></a>

        <div class="method-heading">
          <a href="#M000006" class="method-signature">
          <span class="method-name">recurse_result_set</span><span class="method-args">(result, options = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Loop through set using block pass :nested =&gt; false when result is not
fully parent-child relational for example with filtered result sets Set
options[:sort_on] to the name of a column you want to sort on (optional).
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000006-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000006-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 124</span>
124:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">recurse_result_set</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
125:             <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">result</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">block_given?</span> 
126:             <span class="ruby-identifier">inner_recursion</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:inner_recursion</span>)
127:             <span class="ruby-identifier">result_set</span> = <span class="ruby-identifier">inner_recursion</span> <span class="ruby-value">? </span><span class="ruby-identifier">result</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">dup</span>
128:           
129:             <span class="ruby-identifier">parent_id</span> = (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:parent_id</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>[<span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">parent_col_name</span>]) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
130:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>] <span class="ruby-operator">||=</span> <span class="ruby-value">0</span>
131:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:nested</span>)
132:                    
133:             <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">parent_id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">parent_id</span> } <span class="ruby-operator">:</span> <span class="ruby-identifier">result_set</span>           
134:             <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">sort!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:sort_on</span>]) <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">b</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:sort_on</span>])} <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:sort_on</span>]
135:             <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sibling</span><span class="ruby-operator">|</span>
136:               <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">sibling</span>)           
137:               <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">sibling</span>, <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>])
138:               <span class="ruby-identifier">opts</span> = { <span class="ruby-identifier">:parent_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">:level</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>] <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">:inner_recursion</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>, <span class="ruby-identifier">:sort_on</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:sort_on</span>]}           
139:               <span class="ruby-identifier">recurse_result_set</span>(<span class="ruby-identifier">result_set</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>]
140:             <span class="ruby-keyword kw">end</span>
141:             <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">orphan</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">orphan</span>, <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>]) } <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">inner_recursion</span>
142:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000013" class="method-detail">
        <a name="M000013"></a>

        <div class="method-heading">
          <a href="#M000013" class="method-signature">
          <span class="method-name">renumber_all</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Re-calculate the left/right values of all nodes. Can be used to convert
ordinary trees into nested sets.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000013-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000013-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 318</span>
318:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">renumber_all</span>
319:             <span class="ruby-identifier">scopes</span> = []
320:             <span class="ruby-comment cmt"># only call it once for each scope_condition (if the scope conditions are messed up, this will obviously cause problems)</span>
321:             <span class="ruby-identifier">roots</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
322:               <span class="ruby-identifier">r</span>.<span class="ruby-identifier">renumber_full_tree</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">scopes</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">r</span>.<span class="ruby-identifier">scope_condition</span>)
323:               <span class="ruby-identifier">scopes</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">scope_condition</span>
324:             <span class="ruby-keyword kw">end</span>
325:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000007" class="method-detail">
        <a name="M000007"></a>

        <div class="method-heading">
          <a href="#M000007" class="method-signature">
          <span class="method-name">result_to_array</span><span class="method-args">(result, options = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Loop and create a nested array of hashes (with children property) pass
:nested =&gt; false when result is not fully parent-child relational for
example with filtered result sets
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000007-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000007-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 147</span>
147:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">result_to_array</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
148:             <span class="ruby-identifier">array</span> = []
149:             <span class="ruby-identifier">inner_recursion</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:inner_recursion</span>)
150:             <span class="ruby-identifier">result_set</span> = <span class="ruby-identifier">inner_recursion</span> <span class="ruby-value">? </span><span class="ruby-identifier">result</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">dup</span>
151:           
152:             <span class="ruby-identifier">parent_id</span> = (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:parent_id</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>[<span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">parent_col_name</span>]) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
153:             <span class="ruby-identifier">level</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>]   <span class="ruby-operator">||</span> <span class="ruby-value">0</span>
154:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:children</span>]        <span class="ruby-operator">||=</span> <span class="ruby-value str">'children'</span>
155:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>]         <span class="ruby-operator">||=</span> []
156:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:nested</span>)
157:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:symbolize_keys</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:symbolize_keys</span>)
158:           
159:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>].<span class="ruby-identifier">blank?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>].<span class="ruby-identifier">blank?</span>
160:               <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>] = [<span class="ruby-identifier">:left_column</span>, <span class="ruby-identifier">:right_column</span>, <span class="ruby-identifier">:parent_column</span>].<span class="ruby-identifier">inject</span>([]) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ex</span>, <span class="ruby-identifier">opt</span><span class="ruby-operator">|</span>
161:                 <span class="ruby-identifier">column</span> = <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">opt</span>].<span class="ruby-identifier">to_sym</span>
162:                 <span class="ruby-identifier">ex</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">column</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">ex</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">column</span>)
163:                 <span class="ruby-identifier">ex</span>
164:               <span class="ruby-keyword kw">end</span>
165:             <span class="ruby-keyword kw">end</span>
166:           
167:             <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">parent_id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">parent_id</span> } <span class="ruby-operator">:</span> <span class="ruby-identifier">result_set</span>
168:             <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sibling</span><span class="ruby-operator">|</span>
169:               <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">sibling</span>)
170:               <span class="ruby-identifier">node</span> = <span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">sibling</span>, <span class="ruby-identifier">level</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">attributes</span>(<span class="ruby-identifier">:only</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>], <span class="ruby-identifier">:except</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>]) 
171:               <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>].<span class="ruby-identifier">inject</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">enum</span>, <span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_s</span>] = <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">m</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">m</span>); <span class="ruby-identifier">enum</span> }          
172:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>]              
173:                 <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:parent_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">:level</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">:inner_recursion</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>)
174:                 <span class="ruby-identifier">childnodes</span> = <span class="ruby-identifier">result_to_array</span>(<span class="ruby-identifier">result_set</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
175:                 <span class="ruby-identifier">node</span>[ <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:children</span>] ] = <span class="ruby-identifier">childnodes</span> <span class="ruby-keyword kw">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">childnodes</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:[]=</span>)
176:               <span class="ruby-keyword kw">end</span>
177:               <span class="ruby-identifier">array</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:symbolize_keys</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:symbolize_keys</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">symbolize_keys</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">node</span>)
178:             <span class="ruby-keyword kw">end</span>
179:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">inner_recursion</span>
180:               <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">orphan</span><span class="ruby-operator">|</span> 
181:                 <span class="ruby-identifier">node</span> = (<span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">orphan</span>, <span class="ruby-identifier">level</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">attributes</span>(<span class="ruby-identifier">:only</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>], <span class="ruby-identifier">:except</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>])) 
182:                 <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>].<span class="ruby-identifier">inject</span>(<span class="ruby-identifier">node</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">enum</span>, <span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_s</span>] = <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">m</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">m</span>); <span class="ruby-identifier">enum</span> }
183:                 <span class="ruby-identifier">array</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:symbolize_keys</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">:symbolize_keys</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">symbolize_keys</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">node</span>)
184:               <span class="ruby-keyword kw">end</span>
185:             <span class="ruby-keyword kw">end</span>        
186:             <span class="ruby-identifier">array</span>
187:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000009" class="method-detail">
        <a name="M000009"></a>

        <div class="method-heading">
          <a href="#M000009" class="method-signature">
          <span class="method-name">result_to_attributes_xml</span><span class="method-args">(result, options = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Loop and create a nested xml representation of nodes with attributes pass
:nested =&gt; false when result is not fully parent-child relational for
example with filtered result sets
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000009-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000009-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 242</span>
242:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">result_to_attributes_xml</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
243:             <span class="ruby-identifier">inner_recursion</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:inner_recursion</span>)
244:             <span class="ruby-identifier">result_set</span> = <span class="ruby-identifier">inner_recursion</span> <span class="ruby-value">? </span><span class="ruby-identifier">result</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">dup</span>
245:           
246:             <span class="ruby-identifier">parent_id</span> = (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:parent_id</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>[<span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">parent_col_name</span>]) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
247:             <span class="ruby-identifier">level</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:level</span>] <span class="ruby-operator">||</span> <span class="ruby-value">0</span>          
248:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>]       <span class="ruby-operator">||=</span> []
249:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:nested</span>)
250:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:dasherize</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:dasherize</span>)
251:                     
252:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>].<span class="ruby-identifier">blank?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>].<span class="ruby-identifier">blank?</span>
253:               <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>] = [<span class="ruby-identifier">:left_column</span>, <span class="ruby-identifier">:right_column</span>, <span class="ruby-identifier">:parent_column</span>].<span class="ruby-identifier">inject</span>([]) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">ex</span>, <span class="ruby-identifier">opt</span><span class="ruby-operator">|</span>
254:                 <span class="ruby-identifier">column</span> = <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">opt</span>].<span class="ruby-identifier">to_sym</span>
255:                 <span class="ruby-identifier">ex</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">column</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">ex</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">column</span>)
256:                 <span class="ruby-identifier">ex</span>
257:               <span class="ruby-keyword kw">end</span>
258:             <span class="ruby-keyword kw">end</span>
259:           
260:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:indent</span>]  <span class="ruby-operator">||=</span> <span class="ruby-value">2</span>
261:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">Builder</span><span class="ruby-operator">::</span><span class="ruby-constant">XmlMarkup</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">:indent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:indent</span>])
262:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">instruct!</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:skip_instruct</span>)
263:           
264:             <span class="ruby-identifier">parent_attrs</span> = {}
265:             <span class="ruby-identifier">parent_attrs</span>[<span class="ruby-identifier">:xmlns</span>] = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:namespace</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:namespace</span>]
266:                         
267:             <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">parent_id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">parent_id</span> } <span class="ruby-operator">:</span> <span class="ruby-identifier">result_set</span>          
268:             <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sibling</span><span class="ruby-operator">|</span>
269:               <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">sibling</span>)
270:               <span class="ruby-identifier">node_tag</span> = (<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:record</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">sibling</span>[<span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">inheritance_column</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">'node'</span>).<span class="ruby-identifier">underscore</span>
271:               <span class="ruby-identifier">node_tag</span> = <span class="ruby-identifier">node_tag</span>.<span class="ruby-identifier">dasherize</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:dasherize</span>]
272:               <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">sibling</span>, <span class="ruby-identifier">level</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">attributes</span>(<span class="ruby-identifier">:only</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>], <span class="ruby-identifier">:except</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>])
273:               <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>].<span class="ruby-identifier">inject</span>(<span class="ruby-identifier">attrs</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">enum</span>, <span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_s</span>] = <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">m</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">m</span>); <span class="ruby-identifier">enum</span> }
274:               <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">children?</span>
275:                 <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:parent_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">:level</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">:inner_recursion</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>, <span class="ruby-identifier">:skip_instruct</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>)              
276:                 <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">tag!</span>(<span class="ruby-identifier">node_tag</span>, <span class="ruby-identifier">attrs</span>) { <span class="ruby-identifier">result_to_attributes_xml</span>(<span class="ruby-identifier">result_set</span>, <span class="ruby-identifier">opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) }
277:               <span class="ruby-keyword kw">else</span>
278:                 <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">tag!</span>(<span class="ruby-identifier">node_tag</span>, <span class="ruby-identifier">attrs</span>)
279:               <span class="ruby-keyword kw">end</span>
280:             <span class="ruby-keyword kw">end</span>
281:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">inner_recursion</span>
282:               <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">orphan</span><span class="ruby-operator">|</span>
283:                 <span class="ruby-identifier">node_tag</span> = (<span class="ruby-identifier">options</span>[<span class="ruby-identifier">:record</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">orphan</span>[<span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">inheritance_column</span>] <span class="ruby-operator">||</span> <span class="ruby-value str">'node'</span>).<span class="ruby-identifier">underscore</span>
284:                 <span class="ruby-identifier">node_tag</span> = <span class="ruby-identifier">node_tag</span>.<span class="ruby-identifier">dasherize</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:dasherize</span>]  
285:                 <span class="ruby-identifier">attrs</span> = <span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">orphan</span>, <span class="ruby-identifier">level</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">attributes</span>(<span class="ruby-identifier">:only</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:only</span>], <span class="ruby-identifier">:except</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>])
286:                 <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>].<span class="ruby-identifier">inject</span>(<span class="ruby-identifier">attrs</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">enum</span>, <span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-identifier">enum</span>[<span class="ruby-identifier">m</span>.<span class="ruby-identifier">to_s</span>] = <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">m</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">orphan</span>.<span class="ruby-identifier">respond_to?</span>(<span class="ruby-identifier">m</span>); <span class="ruby-identifier">enum</span> }
287:                 <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">tag!</span>(<span class="ruby-identifier">node_tag</span>, <span class="ruby-identifier">attrs</span>)
288:               <span class="ruby-keyword kw">end</span>
289:             <span class="ruby-keyword kw">end</span>
290:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">target!</span>
291:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000008" class="method-detail">
        <a name="M000008"></a>

        <div class="method-heading">
          <a href="#M000008" class="method-signature">
          <span class="method-name">result_to_xml</span><span class="method-args">(result, options = {}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Loop and create an xml structure. The following options are available :<a
href="SingletonMethods.html#M000010">root</a> sets the <a
href="SingletonMethods.html#M000010">root</a> tag, :children sets the
siblings tag :record sets the node item tag, if given see also: <a
href="SingletonMethods.html#M000007">result_to_array</a> and
ActiveRecord::XmlSerialization
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000008-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000008-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 193</span>
193:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">result_to_xml</span>(<span class="ruby-identifier">result</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
194:             <span class="ruby-identifier">inner_recursion</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:inner_recursion</span>)         
195:             <span class="ruby-identifier">result_set</span> = <span class="ruby-identifier">inner_recursion</span> <span class="ruby-value">? </span><span class="ruby-identifier">result</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">result</span>.<span class="ruby-identifier">dup</span>
196:           
197:             <span class="ruby-identifier">parent_id</span> = (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:parent_id</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>[<span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">parent_col_name</span>]) <span class="ruby-keyword kw">rescue</span> <span class="ruby-keyword kw">nil</span>
198:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] = <span class="ruby-keyword kw">true</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">:nested</span>)
199:           
200:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>] <span class="ruby-operator">||=</span> []
201:             [<span class="ruby-identifier">:left_column</span>, <span class="ruby-identifier">:right_column</span>, <span class="ruby-identifier">:parent_column</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">opt</span><span class="ruby-operator">|</span>
202:               <span class="ruby-identifier">column</span> = <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">opt</span>].<span class="ruby-identifier">intern</span>
203:               <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">column</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:except</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">column</span>)
204:             <span class="ruby-keyword kw">end</span>
205:           
206:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:indent</span>]  <span class="ruby-operator">||=</span> <span class="ruby-value">2</span>
207:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>] <span class="ruby-operator">||=</span> <span class="ruby-constant">Builder</span><span class="ruby-operator">::</span><span class="ruby-constant">XmlMarkup</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">:indent</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:indent</span>])
208:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">instruct!</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:skip_instruct</span>)
209:                     
210:             <span class="ruby-identifier">record</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:record</span>)
211:             <span class="ruby-identifier">root</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:root</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">:nodes</span>
212:             <span class="ruby-identifier">children</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:children</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">:children</span>
213:           
214:             <span class="ruby-identifier">attrs</span> = {}
215:             <span class="ruby-identifier">attrs</span>[<span class="ruby-identifier">:xmlns</span>] = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:namespace</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:namespace</span>] 
216:           
217:             <span class="ruby-identifier">siblings</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">parent_id</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">parent_id</span> } <span class="ruby-operator">:</span> <span class="ruby-identifier">result_set</span>       
218:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">tag!</span>(<span class="ruby-identifier">root</span>, <span class="ruby-identifier">attrs</span>) <span class="ruby-keyword kw">do</span>
219:               <span class="ruby-identifier">siblings</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sibling</span><span class="ruby-operator">|</span>
220:                 <span class="ruby-identifier">result_set</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">sibling</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>]         
221:                 <span class="ruby-identifier">procs</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:procs</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:procs</span>].<span class="ruby-identifier">dup</span> <span class="ruby-operator">:</span> []
222:                 <span class="ruby-identifier">procs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">opts</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">opts</span>, <span class="ruby-identifier">sibling</span>) } <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
223:                 <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:nested</span>] 
224:                   <span class="ruby-identifier">proc</span> = <span class="ruby-constant">Proc</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">opts</span><span class="ruby-operator">|</span> 
225:                     <span class="ruby-identifier">proc_opts</span> = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:parent_id</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">id</span>, <span class="ruby-identifier">:root</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">children</span>, <span class="ruby-identifier">:record</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">record</span>, <span class="ruby-identifier">:inner_recursion</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>)                  
226:                     <span class="ruby-identifier">proc_opts</span>[<span class="ruby-identifier">:procs</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:procs</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:procs</span>]
227:                     <span class="ruby-identifier">proc_opts</span>[<span class="ruby-identifier">:methods</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:methods</span>]
228:                     <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">result_to_xml</span>(<span class="ruby-identifier">result_set</span>, <span class="ruby-identifier">proc_opts</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
229:                   <span class="ruby-keyword kw">end</span>
230:                   <span class="ruby-identifier">procs</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">proc</span>
231:                 <span class="ruby-keyword kw">end</span>       
232:                 <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">:procs</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">procs</span>, <span class="ruby-identifier">:skip_instruct</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>, <span class="ruby-identifier">:root</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">record</span>)           
233:                 <span class="ruby-identifier">sibling</span>.<span class="ruby-identifier">to_xml</span>(<span class="ruby-identifier">opts</span>)
234:               <span class="ruby-keyword kw">end</span>
235:             <span class="ruby-keyword kw">end</span>
236:             <span class="ruby-identifier">options</span>[<span class="ruby-identifier">:builder</span>].<span class="ruby-identifier">target!</span>
237:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000010" class="method-detail">
        <a name="M000010"></a>

        <div class="method-heading">
          <a href="#M000010" class="method-signature">
          <span class="method-name">root</span><span class="method-args">(scope = {})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the single <a href="SingletonMethods.html#M000010">root</a> for the
class (or just the first <a href="SingletonMethods.html#M000010">root</a>,
if there are several). Deprecation note: the original acts_as_nested_set
allowed <a href="SingletonMethods.html#M000011">roots</a> to have parent_id
= 0, so we currently do the same. This silliness will not be tolerated in
future versions, however.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000010-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000010-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 296</span>
296:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">root</span>(<span class="ruby-identifier">scope</span> = {})
297:             <span class="ruby-identifier">find_in_nested_set</span>(<span class="ruby-identifier">:first</span>, { <span class="ruby-identifier">:conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;(#{prefixed_parent_col_name} IS NULL OR #{prefixed_parent_col_name} = 0)&quot;</span> }, <span class="ruby-identifier">scope</span>)
298:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000011" class="method-detail">
        <a name="M000011"></a>

        <div class="method-heading">
          <a href="#M000011" class="method-signature">
          <span class="method-name">roots</span><span class="method-args">(scope = {})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns the <a href="SingletonMethods.html#M000011">roots</a> and/or
virtual <a href="SingletonMethods.html#M000011">roots</a> of all trees. See
the explanation of virtual <a
href="SingletonMethods.html#M000011">roots</a> in the README.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000011-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000011-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 301</span>
301:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">roots</span>(<span class="ruby-identifier">scope</span> = {})
302:             <span class="ruby-identifier">find_in_nested_set</span>(<span class="ruby-identifier">:all</span>, { <span class="ruby-identifier">:conditions</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;(#{prefixed_parent_col_name} IS NULL OR #{prefixed_parent_col_name} = 0)&quot;</span>, <span class="ruby-identifier">:order</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-node">&quot;#{prefixed_left_col_name}&quot;</span> }, <span class="ruby-identifier">scope</span>)
303:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000014" class="method-detail">
        <a name="M000014"></a>

        <div class="method-heading">
          <a href="#M000014" class="method-signature">
          <span class="method-name">sql_for</span><span class="method-args">(items)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Returns an SQL fragment that matches <em>items</em> <b>and</b> all of their
descendants, for use in a WHERE clause. You can pass it a single object, a
single ID, or an array of objects and/or IDs.
</p>
<pre>
  # if a.lft = 2, a.rgt = 7, b.lft = 12 and b.rgt = 13
  Set.sql_for([a,b]) # returns &quot;((lft BETWEEN 2 AND 7) OR (lft BETWEEN 12 AND 13))&quot;
</pre>
<p>
Returns &quot;1 != 1&quot; if passed no items. If you need to exclude
items, just use &quot;NOT (#{<a
href="SingletonMethods.html#M000014">sql_for</a>(items)})&quot;. Note that
if you have multiple trees, it is up to you to apply your scope condition.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000014-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000014-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 333</span>
333:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">sql_for</span>(<span class="ruby-identifier">items</span>)
334:             <span class="ruby-identifier">items</span> = [<span class="ruby-identifier">items</span>] <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
335:             <span class="ruby-comment cmt"># get objects for IDs</span>
336:             <span class="ruby-identifier">items</span>.<span class="ruby-identifier">collect!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>]) <span class="ruby-operator">?</span> <span class="ruby-identifier">s</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">acts_as_nested_set_options</span>[<span class="ruby-identifier">:class</span>].<span class="ruby-identifier">find</span>(<span class="ruby-identifier">s</span>)}.<span class="ruby-identifier">uniq</span>
337:             <span class="ruby-identifier">items</span>.<span class="ruby-identifier">reject!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span>.<span class="ruby-identifier">new_record?</span>} <span class="ruby-comment cmt"># exclude unsaved items, since they don't have left/right values yet</span>
338:           
339:             <span class="ruby-keyword kw">return</span> <span class="ruby-value str">&quot;1 != 1&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">items</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment cmt"># PostgreSQL didn't like '0', and SQLite3 didn't like 'FALSE'</span>
340:             <span class="ruby-identifier">items</span>.<span class="ruby-identifier">map!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;(#{prefixed_left_col_name} BETWEEN #{e[left_col_name]} AND #{e[right_col_name]})&quot;</span> }
341:             <span class="ruby-node">&quot;(#{items.join(' OR ')})&quot;</span>
342:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000015" class="method-detail">
        <a name="M000015"></a>

        <div class="method-heading">
          <a href="#M000015" class="method-signature">
          <span class="method-name">without_scope_condition</span><span class="method-args">() {|| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Wrap a method with this block to disable the default scope_condition
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000015-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000015-source">
<pre>
     <span class="ruby-comment cmt"># File lib/better_nested_set.rb, line 345</span>
345:           <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">without_scope_condition</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
346:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
347:               <span class="ruby-identifier">disable_scope_condition</span>
348:               <span class="ruby-keyword kw">yield</span>
349:               <span class="ruby-identifier">enable_scope_condition</span>
350:             <span class="ruby-keyword kw">end</span>
351:           <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>